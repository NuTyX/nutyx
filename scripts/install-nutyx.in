#***********************************************************************
# Written by Thierry Nuttens
# Copyright Thierry Nuttens 2010 - 2021
# Installation script for the NuTyX system
# Based on LFS scripts
#***********************************************************************

#***********************************************************************
# Function - boot_mesg()
#
# Purpose:      Sending information from bootup scripts to the console
#
# Inputs:       $1 is the message
#               $2 is the colorcode for the console
#
# Outputs:      Standard Output
#
# Dependencies: - sed for parsing strings.
#               - grep for counting string length.
#
# Todo:
#***********************************************************************
boot_mesg() {
	local ECHOPARM=""

	while true
	do
		case "${1}" in
			-n)
				ECHOPARM=" -n "
				shift 1
				;;
			-*)
				echo "Unknown Option: ${1}"
				return 1
				;;
			*)
				break
				;;
		esac
	done

	## Figure out the length of what is to be printed to be used
	## for warning messages.
	STRING_LENGTH=$((${#1} + 1))

	# Print the message to the screen
	${ECHO} ${ECHOPARM} -e "${2}${1}"
}
boot_mesg_flush() {
	# Reset STRING_LENGTH for next message
	STRING_LENGTH="0"
}
echo_ok() {
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${SUCCESS}  OK  ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
	boot_mesg_flush
}
echo_info() {
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${INFO} INFO ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
	boot_mesg_flush
}
echo_failure() {
	${ECHO} -n -e "${CURS_UP}${SET_COL}${BRACKET}[${FAILURE} FAIL ${BRACKET}]"
	${ECHO} -e "${NORMAL}"
	boot_mesg_flush
}
#***********************************************************************
# Function - unmountall
#
# Purpose:	unmount all the mounted disks and partitions
#
# Inputs:	$1 the full path of the Distro
#
# Outputs:	Standard Output
#
# Dependencies: chroot
#
#***********************************************************************
unmountall() {
if [ -d "$DEPOT_CD/depot" ]; then
	umount ${LFS}/${DEPOT}
	umount $(cat /tmp/depot)
fi
[ ! -z $MOUNT ] && umount ${LFS}/${DEPOT}

mountpoint ${LFS}/run > /dev/null && umount ${LFS}/run
mountpoint ${LFS}/dev > /dev/null && umount -R ${LFS}/dev
mountpoint ${LFS}/proc > /dev/null && umount ${LFS}/proc
mountpoint ${LFS}/sys > /dev/null && umount -R ${LFS}/sys
}
#***********************************************************************
# Function - setup_chroot
#
# Purpose:	Enter the NuTyX Distribution
#
# Inputs:	$1 the full path of the Distro
#
# Outputs:	Standard Output
#
# Dependencies: chroot
#
#***********************************************************************
setup_chroot() {
cp /etc/resolv.conf ${LFS}/etc/resolv.conf
mountpoint ${LFS}/dev > /dev/null || mount --bind /dev ${LFS}/dev
mountpoint ${LFS}/dev/pts > /dev/null || mount -t devpts devpts ${LFS}/dev/pts
mountpoint ${LFS}/proc > /dev/null || mount -t proc proc ${LFS}/proc
mountpoint ${LFS}/sys > /dev/null || mount -t sysfs sysfs ${LFS}/sys
mountpoint ${LFS}/run > /dev/null || mount -t tmpfs tmpfs ${LFS}/run
mountpoint ${LFS}/dev/shm > /dev/null || mount -t tmpfs tmpfs ${LFS}/dev/shm

if [ -h ${LFS}/dev/shm ]; then
   mkdir -p ${LFS}/$(readlink ${LFS}/dev/shm)
fi
if [ ! -L ${LFS}/bin/sh ];then
  ln -sv ../sbin/busybox ${LFS}/bin/bash
  ln -sv bash ${LFS}/bin/sh
fi
[ -d /sys/firmware/efi/efivars ] && \
mount -t efivarfs efivarfs ${LFS}/sys/firmware/efi/efivars
}
enter_chroot() {
if [ -f $LFS/$SETUP_FILE ]; then
	CHROOT_SHELL="$SHELL -c $SETUP_FILE"
else
	CHROOT_SHELL="$SHELL -l"
fi
echo "
******************************
Chroot path: $LFS
******************************"
chroot ${LFS} env -i \
HOME=/root \
EUID=0 \
TERM="$TERM" \
PS1='\u:\w\$ ' \
$LINUX_ARCH \
${CHROOT_SHELL}
}
#***********************************************************************
# Function - download_pkg()
#
# Purpose:      Download the selected package
#
# Inputs:       $1 is the package
#
# Dependencies: - curl
#
# Todo:
#***********************************************************************
download_pkg() {
	getPackageFileName ${1}
	if [ ! -f $LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName ]; then
		boot_mesg "Downloading $1..."
		echo_info
		curl -LC - -# --create-dirs \
		${DEPOT_BASE}/${1}/$PackageFileName \
		-o $LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName || \
			error "Cannot download ${DEPOT_BASE}/${1}/$PackageFileName ..., check URL"
		chmod -R 755 $LFS/$DEPOT
		echo_ok
	fi
}
#***********************************************************************
# Function - install_pkg()
#
# Purpose     : Install the selected package
#
# Inputs      : $1 is the package
#               $2 is the group
#		        $3 Option to install, normally nothing except for grub
# Outputs     : Standard Output
#
# Dependencies: boot_mesg
#               pkgadd
#***********************************************************************
install_pkg() {
	getPackageFileName ${1}
	if $TMP/$(dirname $PKGADD)/pkginfo -r $LFS -i| grep "^$1 " \
		> /dev/null; then
		boot_mesg "$1 is already install on $LFS..."
		echo_info
	fi
	if [ -f $LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName ]; then
		# Installing the package
		$TMP/$PKGADD -r $LFS -i \
		$LFS/$DEPOT/${BASE_COLLECTION}/${1}/$PackageFileName \
			|| error "Cannot install $PackageFileName"
		rm -f $LFS/.{PRE,POST,README}
		echo_ok
	else
		error "$PackageFileName not found"
	fi
}
error() {
	echo "
 $1
"
	ERREUR="yes"
	end
	exit 1
}
end() {
	if [ "$ERREUR" == "yes" ]; then
		if [ ! -f $TMP/depot ]; then
			mountpoint ${LFS}/${DEPOT} > /dev/null && umount ${LFS}/${DEPOT}

			boot_mesg "Cleaning up temporary files.."
			boot_mesg "Please correct and start again"
		fi
	fi
	cd ~
	unmountall $LFS > /dev/null 2>&1
	rm -f $LFS/$SETUP_FILE
	rm -rf $TMP
}
#***********************************************************************
# Function getPackageFileName
#
# Purpose:	Get the fullname of the package
#		directory
# Inputs:	$1 is the package name
#
# Dependencies: - curl
#
# Output:       PackageFileName= cpio1414074943i686.cards.tar.xz
#
#***********************************************************************
getPackageFileName() {
	local BUILD_DATE EXT HEAD
	if [ ! -f $LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO ]; then
		curl -LC - -sS --create-dirs \
		${DEPOT_BASE}/${1}/.PKGREPO -o \
		$LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO || \
		error "Cannot download ${DEPOT_BASE}/${1}/.PKGREPO ..., check URL"
		chmod -R 755 $LFS/$DEPOT
	fi
	if [ $(wc -l $LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO|cut -d " " -f1) -eq 0 ]; then
		error "${DEPOT_BASE}/${1} not reacheable.."
	fi
	HEAD=$(head -1 $LFS/$DEPOT/${BASE_COLLECTION}/${1}/.PKGREPO)
	if [ "${HEAD:10:1}" == "#" ]; then
		BUILD_DATE="$(echo $HEAD|cut -d "#" -f1)"
		EXT="$(echo $HEAD|cut -d "#" -f2)"
		PackageFileName="${1}${BUILD_DATE}${ARCH}${EXT}"
	fi
}
install_chroot() {
for i in $CHROOT
do
	download_pkg "$i"
done
for i in $CHROOT
do
	install_pkg "$i"
done
}
generate_etc_bashrc() {
local FILE
FILE="bashrc"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
  return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/bashrc
# Written for Beyond Linux From Scratch
# by James Robertson <jameswrobertson@earthlink.net>
# updated by Bruce Dubbs <bdubbs@linuxfromscratch.org>

# System wide aliases and functions.

# System wide environment variables and startup programs should go into
# /etc/profile.  Personal environment variables and startup programs
# should go into ~/.bash_profile.  Personal aliases and functions should
# go into ~/.bashrc

# Provides a colored /bin/ls command.  Used in conjunction with code in
# /etc/profile.

alias ls='ls --color=auto'

# Provides prompt for non-login shells, specifically shells started
# in the X environment. [Review the LFS archive thread titled
# PS1 Environment Variable for a great case study behind this script
# addendum.]

NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
WHITE="\[\e[1;37m\]"
INFOMACHINE="$(date +%H:%M) $(uname -m) $(uname -r) $(whoami)@$(uname -n)"
prompt_command() {
# Sauvegarde de la pos courante
tput sc
# Calcul de la largeur
let backwash=$(tput cols)-$(echo $INFOMACHINE | wc -m)-2
# Pos des curseurs à la position Y=0, X=longueur calculée
tput cup 0 ${backwash}
# Spécifie la couleur et la casse de la police
tput setaf 4; tput bold
# Affiche le chemin entre crochets
echo -n "["
# Specifie la couleur du chemin
tput setaf 6
# Affiche le chemin complet
echo -n "$INFOMACHINE"
tput setaf 4; tput bold
# Affiche le crochet fermé
echo -n "]"
# Remet le curseur à sa place
tput rc
}
# If you want to see the upper right corner info
# that look like: [10:18 x86_64 6.3.2-NuTyX thierry@nutyx]
# you need to ucomment following line
#PROMPT_COMMAND=prompt_command

case $TERM in
        xterm*|rxvt*)
                TITLEBAR='\[\033]0;\u@\h \007\]'
                ;;
        *)
                TITLEBAR=''
                ;;
esac

if [[ $EUID == 0 ]] ; then
  PS1="$TITLEBAR$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$TITLEBAR$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi
# End /etc/bashrc
EOF
}
generate_udev_retry() {
local FILE
FILE="udev_retry"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/sysconfig/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
########################################################################
# Begin /etc/sysconfig/udev_retry
#
# Description : udev_retry script configuration
#
# Authors     :
#
# Version     : 00.00
#
#
#	Each subsystem that may need to be re-triggered after mountfs
#	runs should be listed in this file.  Probable subsystems to be
#	listed here are rtc (due to /var/lib/hwclock/adjtime) and sound
#	(due to both /var/lib/alsa/asound.state and /usr/sbin/alsactl).
#	Entries are whitespace-separated.
########################################################################

rtc

# End /etc/sysconfig/udev_retry
EOF
}
generate_xdm() {
local FILE
FILE="xdm"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/sysconfig/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
# Which display manager to use (full path):
# DISPLAY_MANAGER=/usr/sbin/lxdm
# DISPLAY_MANAGER=/usr/sbin/xdm
# DISPLAY_MANAGER="/usr/bin/slim -d"
# DISPLAY_MANAGER=/usr/bin/lightdm
# DISPLAY_MANAGER=/usr/sbin/gdm
# DISPLAY_MANAGER=/usr/bin/sddm
# DISPLAY_MANAGER="/usr/dt/bin/dtlogin -daemon"

# Options to pass to the display manager:
DM_OPTIONS=""
EOF
}
generate_createfiles() {
local FILE
FILE="createfiles"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
########################################################################
# Begin /etc/sysconfig/createfiles
#
# Description : Createfiles script config file
#
# Authors     :
#
# Version     : 00.00
#
# Notes       : The syntax of this file is as follows:
# 		if type is equal to "file" or "dir"
#  		<filename> <type> <permissions> <user> <group>
# 		if type is equal to "dev"
#  		<filename> <type> <permissions> <user> <group> <devtype>
#             <major> <minor>
#
# 		<filename> is the name of the file which is to be created
# 		<type> is either file, dir, or dev.
#   			file creates a new file
#   			dir creates a new directory
#   			dev creates a new device
# 		<devtype> is either block, char or pipe
#   			block creates a block device
#   			char creates a character deivce
#   			pipe creates a pipe, this will ignore the <major> and
#           <minor> fields
# 		<major> and <minor> are the major and minor numbers used for
#     the device.
########################################################################
/dev/net      dir 755  root root
/dev/net/tun  dev 666  root root char 10 200
/tmp          dir 1777 root root
# End /etc/sysconfig/createfiles
EOF
}
generate_modules() {
local FILE
FILE="modules"
[ -f ${LFS}/etc/sysconfig/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
########################################################################
# Begin /etc/sysconfig/modules
#
# Description : Module auto-loading configuration
#
# Authors     :
#
# Version     : 00.00
#
# Notes       : The syntax of this file is as follows:
#  		<module> [<arg1> <arg2> ...]
#
# Each module should be on its own line, and any options that you want
# passed to the module should follow it.  The line deliminator is either
# a space or a tab.
########################################################################

# End /etc/sysconfig/modules
EOF
}
generate_mouse() {
local FILE
FILE="mouse"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc/sysconfig ] && mkdir -pv ${LFS}/etc/sysconfig
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/sysconfig/$FILE
   return
fi
cat > ${LFS}/etc/sysconfig/$FILE << "EOF"
MDEVICE="/dev/input/mice"
PROTOCOL="imps2"
EOF
}
generate_inputrc() {
local FILE
FILE="inputrc"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/inputrc
# Modified by Chris Lynn <roryo@roryo.dynup.net>

# Allow the command prompt to wrap to the next line
set horizontal-scroll-mode Off

# Enable 8bit input
set meta-flag On
set input-meta On

# Turns off 8th bit stripping
set convert-meta Off

# Keep the 8th bit for display
set output-meta On

# none, visible or audible
set bell-style none

# All of the following map the escape sequence of the value
# contained in the 1st argument to the readline specific functions
"\eOd": backward-word
"\eOc": forward-word

# for linux console
"\e[1~": beginning-of-line
"\e[4~": end-of-line
"\e[5~": beginning-of-history
"\e[6~": end-of-history
"\e[3~": delete-char
"\e[2~": quoted-insert

# for xorg-term
"\eOH": beginning-of-line
"\eOF": end-of-line

# for Konsole
"\e[H": beginning-of-line
"\e[F": end-of-line

# End /etc/inputrc
EOF
}
generate_hosts() {
local FILE
FILE="hosts"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
  cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
  return
fi
cat > ${LFS}/etc/$FILE << "EOF"
127.0.0.1 localhost.localdomain localhost
EOF
}
generate_shells() {
local FILE
FILE="shells"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
  cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
  return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/shells
/bin/sh
/bin/bash
EOF
}
generate_umask_sh() {
local FILE
FILE="umask.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
# By default we want the umask to get set.
if [ "$(id -gn)" = "$(id -un)" -a $EUID -gt 99 ] ; then
  umask 002
else
  umask 022
fi
EOF
}
generate_readline_sh() {
local FILE
FILE="readline.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
# Setup the INPUTRC environment variable.
if [ -z "$INPUTRC" -a ! -f "$HOME/.inputrc" ] ; then
        INPUTRC=/etc/inputrc
fi
export INPUTRC
EOF
}
generate_extrapaths_sh() {
local FILE
FILE="extrapaths.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
if [ -d /usr/local/lib/pkgconfig ] ; then
        pathappend /usr/local/lib/pkgconfig PKG_CONFIG_PATH
fi
if [ -d /usr/local/bin ]; then
        pathprepend /usr/local/bin
fi
if [ -d /usr/local/sbin -a $EUID -eq 0 ]; then
        pathprepend /usr/local/sbin
fi

if [ -d ~/bin ]; then
        pathprepend ~/bin
fi
#if [ $EUID -gt 99 ]; then
#        pathappend .
#fi
EOF
}
generate_dircolors_sh() {
local FILE
FILE="dircolors.sh"
[ -f ${LFS}/etc/profile.d/$FILE ] && return
[ ! -d ${LFS}/etc/profile.d ] && mkdir -pv ${LFS}/etc/profile.d
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/profile.d/$FILE
   return
fi
cat > ${LFS}/etc/profile.d/$FILE << "EOF"
# Setup for /bin/ls to support color, the alias is in /etc/bashrc.
if [ -f "/etc/dircolors" ] ; then
        eval $(dircolors -b /etc/dircolors)

        if [ -f "$HOME/.dircolors" ] ; then
                eval $(dircolors -b $HOME/.dircolors)
        fi
fi
alias ls='ls --color=auto'
EOF
}
generate_profile() {
local FILE
FILE="profile"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/profile
# Written for Beyond Linux From Scratch
# by James Robertson <jameswrobertson@earthlink.net>
# modifications by Dagmar d'Surreal <rivyqntzne@pbzpnfg.arg>

# System wide environment variables and startup programs.

# System wide aliases and functions should go in /etc/bashrc.  Personal
# environment variables and startup programs should go into
# ~/.bash_profile.  Personal aliases and functions should go into
# ~/.bashrc.

# Functions to help us manage paths.  Second argument is the name of the
# path variable to be modified (default: PATH)
pathremove () {
        local IFS=':'
        local NEWPATH
        local DIR
        local PATHVARIABLE=${2:-PATH}
        for DIR in ${!PATHVARIABLE} ; do
                if [ "$DIR" != "$1" ] ; then
                  NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
                fi
        done
        export $PATHVARIABLE="$NEWPATH"
}

pathprepend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="$1${!PATHVARIABLE:+:${!PATHVARIABLE}}"
}

pathappend () {
        pathremove $1 $2
        local PATHVARIABLE=${2:-PATH}
        export $PATHVARIABLE="${!PATHVARIABLE:+${!PATHVARIABLE}:}$1"
}

[ "$SHELL" == "/bin/bash" ] &&  export -f pathremove pathprepend pathappend

# Set the initial path
export PATH=/usr/bin:/bin:/usr/sbin:/sbin

if [ $EUID -eq 0 ] ; then
        unset HISTFILE
fi

# Setup some environment variables.
export HISTSIZE=1000
export HISTIGNORE="&:[bf]g:exit"

# Set some defaults for graphical systems
export XDG_DATA_DIRS=${XDG_DATA_DIRS:-/usr/share}
export XDG_CONFIG_DIRS=${XDG_CONFIG_DIRS:-/etc/xdg}
export XDG_RUNTIME_DIR=${XDG_RUNTIME_DIR:-/tmp/xdg-$USER}

# Setup a red prompt for root and a green one for users.
NORMAL="\[\e[0m\]"
RED="\[\e[1;31m\]"
GREEN="\[\e[1;32m\]"
if [[ $EUID == 0 ]] ; then
  PS1="$RED\u [ $NORMAL\w$RED ]# $NORMAL"
else
  PS1="$GREEN\u [ $NORMAL\w$GREEN ]\$ $NORMAL"
fi

for script in /etc/profile.d/*.sh ; do
        if [ -r $script ] ; then
                . $script
        fi
done

unset script RED GREEN NORMAL

# End /etc/profile
EOF
}
generate_group() {
local FILE
FILE="group"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
cat > ${LFS}/etc/$FILE << "EOF"
root:x:0:
bin:x:1:daemon
sys:x:2:
kmem:x:3:
tape:x:4:
tty:x:5:
daemon:x:6:
floppy:x:7:
disk:x:8:
lp:x:9:
dialout:x:10:
audio:x:11
video:x:12
utmp:x:13:
usb:x:14:
cdrom:x:15:
adm:x:16:
atd:x:17:
messagebus:x:18:
lpadmin:x:19:
input:x:24:
man:x:29
wheel:x:30:root
mail:x:34:
games:x:60:
kvm:x:61:
scanner:x:70:
netdev:x:86:
unbound:x:88:
users:x:999:
nogroup:x:65534:
EOF
}
generate_passwd() {
local FILE
FILE="passwd"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
cat > ${LFS}/etc/$FILE << "EOF"
root::0:0:root:/root:/bin/bash
bin:x:1:1:bin:/dev/null:/bin/false
daemon:x:6:6:Daemon User:/dev/null:/bin/false
lp:x:9:9:Print Service User:/dev/null:/bin/false
atd:x:17:17:add daemon:/dev/null:/bin/false
messagebus:x:18:18:D-Bus Message Daemon User:/dev/null:/bin/false
man:x:29:29:Man Pages:/dev/null:/bin/false
games:x:60:60:Games High Score Owner:/var/games:/bin/false
unbound:x:88:88:Unbound DNS resolver:/var/lib/unbound:/bin/false
anonymous:x:98:99:Unprivileged User:/dev/null:/bin/false
nobody:x:99:99:Unprivileged User:/dev/null:/bin/false
EOF
}
generate_fstab() {
local FILE
FILE="fstab"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi
cat > ${LFS}/etc/$FILE << "EOF"
# Begin /etc/fstab

# filesystem  mount-point                  type       options                        dump  fsck
#                                                              order
# Exemple de montage nfs
# 192.168.254.254:/home/thierry /home/thierry nfs rw,vers=3,_netdev,rsize=8192,wsize=8192 0 0
EOF
}
generate_bashrc() {
local FILE
FILE=".bashrc"
[ -f ${LFS}/etc/skel/$FILE ] && return
[ ! -d ${LFS}/etc/skel ] && mkdir -pv ${LFS}/etc/skel
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/skel/$FILE
   return
fi
cat > ${LFS}/etc/skel/$FILE << "EOF"
# Personal aliases and functions.

# Personal environment variables and startup programs should go in
# ~/.bash_profile.  System wide environment variables and startup
# programs are in /etc/profile.  System wide aliases and functions are
# in /etc/bashrc.

if [ -f "/etc/bashrc" ] ; then
  source /etc/bashrc
fi
if [ $EUID -eq 0 ] ; then
        alias nu='setup-nutyx -cu'
        alias del='cards remove'
        alias get='cards install'
        alias up='cards install -u'
        alias check='cards diff'
        alias sysup='cards upgrade'
	alias upcheck='cards sync && cards upgrade -s'
else
        alias nu='sudo setup-nutyx -cu'
        alias del='sudo cards remove'
        alias get='sudo cards install'
        alias up='sudo cards install -u'
        alias check='sudo cards diff'
        alias sysup='sudo cards upgrade'
	alias upcheck='sudo cards sync && sudo cards upgrade -s'
fi
alias search='cards search'
alias ll='ls -l'
alias l='ls -alh'
alias duh='du -h --max-depth=1'
alias dfh='df -h'
alias pkgfind='cards list | grep -i'
alias paste-nutyx='curl -F '\''f:1=<-'\'' ix.io'

$(which neofetch)
# End ~/.bashrc
EOF
[ -f ${LFS}/root/$FILE ] && return
[ ! -d ${LFS}/root ] && install -dv -m0750 ${LFS}/root
cp -v ${LFS}/etc/skel/$FILE \
${LFS}/root
}
generate_bash_profile() {
local FILE
FILE=".bash_profile"
[ -f ${LFS}/etc/skel/$FILE ] && return
[ ! -d ${LFS}/etc/skel ] && mkdir -pv ${LFS}/etc/skel
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/skel/$FILE
   return
fi
cat > ${LFS}/etc/skel/$FILE << "EOF"
# Personal environment variables and startup programs.

# Personal aliases and functions should go in ~/.bashrc.  System wide
# environment variables and startup programs are in /etc/profile.
# System wide aliases and functions are in /etc/bashrc.

append () {
  # First remove the directory
  local IFS=':'
  local NEWPATH
  for DIR in $PATH; do
     if [ "$DIR" != "$1" ]; then
       NEWPATH=${NEWPATH:+$NEWPATH:}$DIR
     fi
  done
  # Then append the directory
  export PATH=$NEWPATH:$1
}

if [ -f "$HOME/.bashrc" ] ; then
  source $HOME/.bashrc
fi

# unset append

# End ~/.bash_profile
EOF
[ ! -d ${LFS}/root ] && install -dv -m0750 ${LFS}/root
[ -f ${LFS}/root/$FILE ] && return
cp -v ${LFS}/etc/skel/$FILE \
${LFS}/root
}
generate_gtkrc() {
local FILE
FILE=".gtkrc-2.0"
[ -f ${LFS}/etc/skel/$FILE ] && return
[ ! -d ${LFS}/etc/skel ] && mkdir -pv ${LFS}/etc/skel
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/skel/$FILE
   return
fi
cat > ${LFS}/etc/skel/$FILE << "EOF"
gtk-theme-name="Adwaita"
gtk-icon-theme-name="Adwaita"
gtk-font-name="DejaVu Sans 10"
gtk-cursor-theme-name="DMZ-Black"
gtk-cursor-theme-size=0
gtk-toolbar-style=GTK_TOOLBAR_ICONS
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=1
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle="hintslight"
gtk-xft-rgba="rgb"
EOF
}
generate_settings_ini(){
local FILE
FILE="settings.ini"
[ -f ${LFS}/etc/skel/.config/gtk-3.0/$FILE ] && return
[ ! -d ${LFS}/etc/skel/.config/gtk-3.0 ] \
&& mkdir -pv ${LFS}/etc/skel/.config/gtk-3.0

if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/skel/.config/gtk-3.0/$FILE
   return
fi
cat > ${LFS}/etc/skel/.config/gtk-3.0/$FILE << "EOF"
[Settings]
gtk-theme-name=Adwaita
gtk-icon-theme-name=Adwaita
gtk-font-name=DejaVu Sans 10
gtk-cursor-theme-name=DMZ-Black
gtk-cursor-theme-size=0
gtk-toolbar-style=GTK_TOOLBAR_BOTH
gtk-toolbar-icon-size=GTK_ICON_SIZE_LARGE_TOOLBAR
gtk-button-images=1
gtk-menu-images=1
gtk-enable-event-sounds=0
gtk-enable-input-feedback-sounds=0
gtk-xft-antialias=1
gtk-xft-hinting=1
gtk-xft-hintstyle=hintslight
gtk-xft-rgba=rgb
EOF
}
generate_pkgmk_conf() {
local FILE
FILE="pkgmk.conf"
[ -f ${LFS}/etc/$FILE ] && return
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
  [ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
  cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
  ${LFS}/etc/$FILE
fi
}
generate_cards_conf() {
local FILE
FILE="cards.conf"
[ -f ${LFS}/etc/$FILE ] && return
[ ! -d ${LFS}/etc ] && mkdir -pv ${LFS}/etc
if [ -f /etc/${INSTALL_COMMAND}.conf.d/$FILE ]; then
   cp /etc/${INSTALL_COMMAND}.conf.d/$FILE \
   ${LFS}/etc/$FILE
   return
fi

[ "$DEPOT" == "$MOUNT" ] || echo "
# Default server URL
url ${URL}" >> ${LFS}/etc/cards.conf

echo "
#
## For all the graphical applications and desktops
dir ${DEPOT}/gui-extra
#
## For a minimal graphical interface
dir ${DEPOT}/gui
#
## For all the console applications
dir ${DEPOT}/cli-extra
#
## For a minimal console interface
dir ${DEPOT}/cli
#
## Chroot system without reboot possibilities for a chroot
dir ${DEPOT}/base
#
## Normaly you want to keep base and
base ${DEPOT}/base
#
#
## If you want to keep more collections remove comments below
# Adjust to your needs
#
# base ${DEPOT}/cli
# base ${DEPOT}/cli-extra
# base ${DEPOT}/gui
# base ${DEPOT}/gui-extra
# base ${DEPOT}/..." >> ${LFS}/etc/cards.conf
}
generate_nutyx_version() {
local FILE
FILE="nutyx-version"
[ -f ${LFS}/var/lib/pkg/$FILE ] && return
[ ! -d ${LFS}/var/lib/pkg ] && mkdir -pv ${LFS}/var/lib/pkg
echo "name ${CODE_NAME}
version $VERSION" > ${LFS}/var/lib/pkg/$FILE
}
generate_lsb() {
echo "DISTRIB_ID=\"NuTyX\"
DISTRIB_DESCRIPTION=\"NuTyX GNU/Linux\"
DISTRIB_CODENAME=\"${CODE_NAME}\"
DISTRIB_RELEASE=\"$VERSION\"
LSB_VERSION=\"1.4-1\"" > ${LFS}/etc/lsb-release
}
generate_osr() {
mkdir -p ${LFS}/usr/lib
echo "NAME=\"NuTyX\"
VERSION=\"$VERSION\"
ID=nutyx
PRETTY_NAME=\"NuTyX GNU/Linux\"
VERSION_CODENAME=\"${CODE_NAME}\"" > ${LFS}/usr/lib/os-release
ln -svf ../usr/lib/os-release ${LFS}/etc/os-release
}


install_resolv_conf() {
[ -f /etc/resolv.conf ] && cp /etc/resolv.conf ${LFS}/etc
}
successfull_installation () {
echo "
****************************************************
      Installation of NuTyX $VERSION installed
      in $LFS sucessfully
****************************************************

****************************************************
* Thanks for installing NuTyX. Make sure to review *
*                                                  *
*       http://www.nutyx.org/en/install-nutyx      *
*                                                  *
*    Check your /etc/cards.conf file so that       *
*         it's fits your requirements              *
*                                                  *
****************************************************
"
}
check_tools() {
local FILE
[ ! -f "$(which curl)" ] && error "You need to install 'curl'"
[ ! -f "$(which bsdtar)" ] && error "You need to install 'libarchive'"
[ -z $ISO ] && return

[ ! -f "$(which xorriso)" ] && error "You need to install 'libisoburn'"
[ ! -f "$(which isohybrid)" ] && error "You need to install 'syslinux'"
[ ! -f "$(which fatlabel)" ] && error "You need to install 'dosfstools'"
[ ! -f "$(which mksquashfs)" ] && error "You need to install 'squashfs'"

for FILE in libutil.c32 libcom32.c32 ldlinux.c32 vesamenu.c32 isolinux.bin
do
	[ ! -f /usr/lib/syslinux/$FILE ] && \
		error "syslinux not properly installed"
done

}
check_root() {
if [ "$UID" -ne 0 ]; then
	echo "
You are not root, cannot continue...
"
	exit 1
fi
}
check_variables() {

CR="nutyx busybox curl gcc bzip2 glibc \
zlib lz4 xz zstd libarchive openssl cards"

if [ -z "$CHROOT" ]; then
	CHROOT="$CR"
else
	CHROOT="$CR $CHROOT"
fi

[ "$ARCH" = "i686" -a "$HOST_ARCH" = "x86_64" ] && \
	CHROOT="$CR util-linux"
unset CR

[ -z "$URL" ] && URL="http://downloads.nutyx.org"

[ -z "$VERSION" ] && VERSION="rolling"
if [ "$VERSION" == "development" ]; then
	CODE_NAME="$(date +%Y%m%d)"
else
	CODE_NAME="Houaphan"
fi

[ -z "$DEPOT" ] && DEPOT="/var/lib/pkg/depot"
[ -z "$LFS" ] && LFS="/mnt/hd"

[ -z "$STRICT" ] && STRICT="$KERNEL"
[ -z "$MINI" ] && MINI="dhcpcd"
[ -z "$BASE" ] && BASE="mdadm efibootmgr linux-firmware lvm2 \
systemd wireless-tools wpa-supplicant"
[ -z "$CLI" ] && CLI="gpm gpm.service make-ca xdg-user-dirs \
sound-theme-freedesktop ntp ntp.service nano neofetch"
[ -z "$GUI" ] && GUI="flcards gvfs network-manager-applet \
ttf-croscore ttf-carlito"
[ -z "$XORG" ] && XORG="xorg xorg-xf86-input-synaptics \
xorg-xf86-input-wacom xorg-xf86-video-ati \
xorg-xf86-video-fbdev xorg-xf86-video-intel \
xorg-xf86-video-nouveau xorg-xf86-video-vesa \
xorg-xrandr xorg-setxkbmap gnome-themes-extra"

[ -z "$GUI_EXTRA" ] && GUI_EXTRA="firefox gparted scrot vlc"
[ -z "$KDE5_EXTRA" ] && KDE5_EXTRA="k3b"
[ -z "$GNOME_EXTRA" ] && GNOME_EXTRA="epiphany seahorse-nautilus \
simple-scan gnome-weather gnome-chess"
[ -z "$CDE" ] && CDE="cde"
[ -z "$OPENBOX" ] && OPENBOX="lxdm openbox openbox-jp-theme"
[ -z "$JWM" ] && JWM="lxdm jwm jwm-miyolinux-theme"
[ -z "$LXDE" ] && LXDE="lxdm lxde"
[ -z "$LXQT" ] && LXQT="breeze-gtk sddm lxqt"
[ -z "$ENLIGHTENMENT" ] && ENLIGHTENMENT="lightdm enlightenment"
[ -z "$XFCE4" ] && XFCE4="lxdm xfce4 xfce4-extra"
[ -z "$CINNAMON" ] && CINNAMON="lightdm cinnamon"
[ -z "$MATE" ] && MATE="lightdm mate"
[ -z "$GNOME" ] && GNOME="gnome"
[ -z "$KDE5" ] && KDE5="adwaita-qt kde5"
[ -z "$BUDGIE" ] && BUDGIE="budgie"

[ "$KERNEL" = "NONE" ] && KERNEL="none"

if [ "$KERNEL" != "none"  ]; then
	if [ ! -z $ISO ]; then
		[ -z $KERNEL ] && KERNEL=kernel
	fi
	CORE="acl attr bash coreutils readline \
expat ncurses gmp flex file gzip mpc mpfr \
grep sed findutils binutils \
inetutils diffutils shadow \
bc less libcap util-linux \
kmod kbd pam \
gdbm e2fsprogs libpipeline \
gettext procps-ng \
psmisc sudo tzdata \
iproute2 iana-etc \
groff man-db \
cards.man nutyx.man \
dialog cpio \
lsb-release grub eudev \
sysklogd sysvinit $KERNEL "
fi

VERSION_KERNEL="$(basename lib/modules/*)"
VERSION_KERNEL=${KERNEL/*-/}
[ "$VERSION_KERNEL" == "kernel" ] && VERSION_KERNEL="stable"

if [ ! -z $ISO ]; then
	ISO=${ISO^^}
	case ${ISO} in
		STRICT) CORE+="$STRICT";;
		MINI) CORE+="$STRICT $MINI";;
		BASE) CORE+="$STRICT $MINI $BASE";;
		CLI) CORE+="$STRICT $MINI $BASE $CLI";;
		GUI) CORE+="$STRICT $MINI $BASE $CLI $GUI";;
		XORG) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG";;
		GUI_EXTRA) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA}";;
		CDE) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $CDE";;
		OPENBOX) CORE+="$STRICT $MINI $BASE $CLI $GUI ${GUI_EXTRA} $XORG $OPENBOX";;
		JWM) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $JWM";;
		LXDE) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $LXDE";;
		LXQT) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $LXQT";;
		XFCE4) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $XFCE4";;
		CINNAMON) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $CINNAMON";;
		ENLIGHTENMENT) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $ENLIGHTENMENT";;
		MATE) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $MATE";;
		GNOME) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG $GUI_EXTRA $GNOME ${GNOME_EXTRA}";;
		KDE5) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG $GUI_EXTRA $KDE5 $KDE5_EXTRA";;
                BUDGIE) CORE+="$STRICT $MINI $BASE $CLI $GUI $XORG ${GUI_EXTRA} $BUDGIE";;
		*) echo "Valid ISO names: strict, mini, base, cli, gui, xorg, gui_extra, \
cde, openbox, jwm, lxde, lxqt, enlightenment, cinnamon, xfce4, budgie, mate, gnome, kde5" && exit 1;;
	esac
fi
if [ ! -z "$ISO" ];then
	DEVEL+="
mkinitramfs \$(basename /lib/modules/*)
mv boot/initrd-* boot/initrd-${VERSION_KERNEL}"
	if [ -z $MOUNT ]; then
		DEVEL+="
cards purge"
	else
		DEVEL+="
umount $DEPOT"
	fi
	DEVEL+="
exit 0"
fi

HOMEPAGE="${URL}"                           ## http://downloads.nutyx.org
INSTALL_BASE="$ARCH/$VERSION"               ## x86_64/rolling
DEPOT_ROOT="$HOMEPAGE/${INSTALL_BASE}"      ## http://downloads.nutyx.org/x86_64/rolling
DEPOT_BASE="$DEPOT_ROOT/${BASE_COLLECTION}" ## http://downloads.nutyx.org/x86_64/rolling/base

LOCAL_DEPOT_PACKAGES="$DEPOT/${BASE_COLLECTION}"
DEPOT_CD="/media/cdrom"

SETUP_FILE="/tmp/setup"
ISO_FILE="NuTyX_${ARCH}-$VERSION_NUTYX-$ISO.iso"
}
config() {
[ -f /etc/$(basename $INSTALL_COMMAND).conf ] && \
		source /etc/$(basename $INSTALL_COMMAND).conf

HOST_ARCH=$(uname -m)
[ -z "$ARCH" ] && ARCH=$(uname -m)
[ "$ARCH" = "i686" -a "$HOST_ARCH" = "x86_64" ] && LINUX_ARCH="linux32" \
	|| LINUX_ARCH=""

# Number of seconds between STOPSIG and FALLBACK when stopping processes
KILLDELAY="3"

## Screen Dimensions
# Find current screen size

if [ -z "${COLUMNS}" ]; then
        COLUMNS=$(stty size)
        COLUMNS=${COLUMNS##* }
fi

# When using remote connections, such as a serial port, stty size returns 0
if [ "${COLUMNS}" = "0" ]; then
        COLUMNS=80
fi

## Measurements for positioning result messages
COL=$((${COLUMNS} - 8))
WCOL=$((${COL} - 2))

## Provide an echo that supports -e and -n
# If formatting is needed, $ECHO should be used
case "$(echo -e -n test)" in
        -[en]*)
                ECHO=$(which echo)
                ;;
        *)
                ECHO=echo
                ;;
esac

## Set Cursor Position Commands, used via $ECHO
SET_COL="\\033[${COL}G"      # at the $COL char
SET_WCOL="\\033[${WCOL}G"    # at the $WCOL char
CURS_UP="\\033[1A\\033[0G"   # Up one line, at the 0'th char

## Set color commands, used via $ECHO
# Please consult man console_codes for more information
# under the "ECMA-48 Set Graphics Rendition" section
#
# Warning: when switching from a 8bit to a 9bit font,
# the linux console will reinterpret the bold (1;) to
# the top 256 glyphs of the 9bit font.  This does
# not affect framebuffer consoles
NORMAL="\\033[0;39m"         # Standard console grey
SUCCESS="\\033[1;32m"        # Success is green
WARNING="\\033[1;33m"        # Warnings are yellow
FAILURE="\\033[1;31m"        # Failures are red
INFO="\\033[1;36m"           # Information is light cyan
BRACKET="\\033[1;34m"        # Brackets are blue
STRING_LENGTH="0"            # the length of the current message
}
mount_depot() {
if [ ! -z $MOUNT ]; then
	mkdir -p $LFS/$DEPOT
	[ -d $MOUNT/$ARCH/$VERSION/${BASE_COLLECTION} ] \
		|| error "$MOUNT/$ARCH/$VERSION/${BASE_COLLECTION} not exist"

	mount --bind $MOUNT/$ARCH/$VERSION  $LFS/$DEPOT \
		|| error "cannot mount $MOUNT on $LFS/$DEPOT"
fi
}
check_arch() {
if [ "$ARCH" != "x86_64" ] && [ "$ARCH" != "i686" ] \
	&& [ "$ARCH" != "aarch64" ]; then
	boot_mesg "
 >>> This arch ($ARCH) is not supported"
	echo_failure
	exit 1
fi
}

create_locale_link() {
[ ! -d ${LFS}/etc/locale ] && mkdir -p ${LFS}/etc/locale
if [ -d ${LFS}/usr/lib/locale ]; then
   rm -r ${LFS}/usr/lib/locale
   ln -sv /etc/locale/ ${LFS}/usr/lib/locale
fi
}
make_directories() {
mkdir -p ${LFS}/{dev,sys,proc,run,tmp,srv,mnt}
mkdir -p ${LFS}/var/tmp
mkdir -p ${LFS}/usr/{,local/}lib

chmod 1777 ${LFS}/{,var/}tmp

mkdir -p ${LFS}/var/{mail,spool}
mkdir -p ${LFS}/var/run/lock

mknod -m 600 ${LFS}/dev/console c 5 1
mknod -m 666 ${LFS}/dev/null c 1 3
}
download_pkgadd() {
	PKGADD="$(which pkgadd)"
	if [ "$PKGADD" != "" ];then
		mkdir -p $TMP/$(dirname $PKGADD)
		cp  $PKGADD $TMP/$(dirname $PKGADD)/
		ln -s $TMP/$(dirname $PKGADD)/pkgadd  $TMP/$(dirname $PKGADD)/pkginfo
	else
		PKGADD="/bin/pkgadd"

		getPackageFileName cards

		if [ ! -f $TMP/$PKGADD ]; then
			cd $TMP
			PackageFileName=""
			getPackageFileName cards
			if [ "$PackageFileName" == "" ]; then
				error "variable 'PackageFileName' is not set"
			fi
			download_pkg cards
			echo "Extraction of cards ..."
			bsdtar -xf $LFS/$DEPOT/${BASE_COLLECTION}/cards/${PackageFileName} \
				|| error "Cannot extract $LFS/$DEPOT/${BASE_COLLECTION}/cards/${PackageFileName}"
			echo_ok
		fi
	fi
}
generate_setupfile() {
if [ "$SHELL" == "/bin/bash" ]; then
  SHELL=/bin/ash
  if [ -f $LFS/bin/bash ]; then
	SHELL=/bin/bash
  fi
fi
if [[ -z "$CORE" && -z "$DEVEL" ]];then
	echo "exit" > $LFS/$SETUP_FILE
else
	echo "source /etc/profile" \
	 > $LFS/$SETUP_FILE
	[ -z $MOUNT ] && echo "cards sync" >> \
	$LFS/$SETUP_FILE
	echo "cards install -n $CORE $DEVEL
which genfstab > /dev/null && genfstab >> /etc/fstab
exit" >> $LFS/$SETUP_FILE
fi
chmod 177 $LFS/$SETUP_FILE
}
install_configuration_files() {
	generate_cards_conf
	generate_pkgmk_conf
	generate_fstab
	generate_passwd
	generate_group
	generate_bash_profile
	generate_bashrc
	generate_gtkrc
	generate_settings_ini
	generate_hosts
	generate_inputrc
	generate_shells
	generate_dircolors_sh
	generate_extrapaths_sh
	generate_readline_sh
	generate_umask_sh
	generate_profile
	generate_inputrc
	generate_modules
	generate_createfiles
	generate_mouse
	generate_udev_retry
	generate_etc_bashrc
	generate_lsb
	generate_osr
	generate_nutyx_version
}
show_variables() {
echo "
List of variables: 

LFS          : $LFS
URL          : $URL
ARCH         : $ARCH
VERSION      : $VERSION
KERNEL       : $KERNEL
DEPOT        : $DEPOT
MOUNT        : $MOUNT
SHELL        : $SHELL
DEPOT_BASE   : $DEPOT_BASE
CHROOT       : $CHROOT
CORE         : $CORE
DEVEL        : $DEVEL
ISO          : $ISO"
[ -z "$ISO" ] || echo "STRICT       : $STRICT
MINI         : $MINI
BASE         : $BASE
CLI          : $CLI
GUI          : $GUI
GUI_EXTRA    : $GUI_EXTRA
XORG         : $XORG
GNOME_EXTRA  : ${GNOME_EXTRA}
KDE5_EXTRA   : ${KDE5_EXTRA}
CDE          : $CDE
OPENBOX      : $OPENBOX
JWM          : $JWM
LXDE         : $LXDE
LXQT         : $LXQT
CINNAMON     : $CINNAMON
ENLIGHTENMENT: $ENLIGHTENMENT
XFCE4        : $XFCE4
BUDGIE       : $BUDGIE
MATE         : $MATE
GNOME        : $GNOME
KDE5         : $KDE5
ISO Filename : $ISO_FILE"
}
print_help() {
	echo "
usage: $(basename ${INSTALL_COMMAND}) [options]
options

  -ec,  --enter-chroot    will enter in the chroot if exist
  -ic,  --install-config  will install all the configuration files only
   -t,  --test            print all the variables and exit
   -h,  --help            print help and exit
   -v,  --version         print the version and exit
"

}

parse_options() {
	while [ "${INSTALL_COMMAND}" ];do
		case ${INSTALL_COMMAND} in
			"chroot-nutyx")
				check_root
				setup_chroot
				mount_depot
				enter_chroot
				unmountall
				exit 0;;
			"generate-nutyx")
				check_root
				setup_chroot
				echo "mkinitramfs \$(basename /lib/modules/*)
mv boot/initrd-* boot/initrd-${VERSION_KERNEL}
exit 0" > $LFS/$SETUP_FILE
				chmod 177 $LFS/$SETUP_FILE
				enter_chroot
				unmountall
				rm -rf $LFS/ISO
				rm -f $LFS/*.iso
				generate_squashfs
				generate_iso
				end
				exit 0;;

			*)
				break;;
		esac
	done

	while [ "$1" ]; do
		case $1 in
			-h|--help)
				print_help
				exit 0;;
			-t|--test)
				show_variables
				exit 0;;
			-ec|--enter-chroot)
				check_root
				setup_chroot
				mount_depot
				enter_chroot
				unmountall
				exit 0;;
			-ic|--install-config)
				check_root
				mkdir -p $LFS
				make_directories
				create_locale_link
				install_configuration_files
				exit 0;;
			-v|--version)
				echo "$(basename $INSTALL_COMMAND) $VERSION_NUTYX-$RELEASE"
				exit 0;;
			/*)
				boot_mesg "
 >>> Do not use arguments anymore ...
"
				exit 1;;
			*)
				echo "$(basename $0): invalid option $1"
				exit 1 ;;
		esac
		shift
	done
}
generate_squashfs() {
local DIRS
cd $LFS
mkdir -p ISO/boot
for d in opt bin etc lib lib64 root run sbin usr var home
do
  [ ! -d $d ] && continue
  DIRS+="$d "
done
mksquashfs $DIRS ISO/boot/NuTyX.squashfs
}
generate_iso() {
local FILE MD5SUM LABEL GRUB_EFI_ARCH GRUB_EFI_IMG ISODIR \
SCRIPTDIR

LABEL="nutyxcd"

[ "$(uname -m)" == "x86_64" ] &&  GRUB_EFI_ARCH="x86_64"
[ "$(uname -m)" == "i686" ] &&  GRUB_EFI_ARCH="i386"
[ "$(uname -m)" == "x86_64" ] && GRUB_EFI_IMG="bootx64.efi"
[ "$(uname -m)" == "i686" ] && GRUB_EFI_IMG="bootia32.efi"

ISODIR=$LFS/ISO
mkdir -p $ISODIR/{iso,isolinux}

SCRIPTDIR=$(pwd -P)

cd $LFS


cp -va boot ISO/

cd ${ISODIR} || error "cd ${ISODIR}"

for FILE in libutil.c32 libcom32.c32 ldlinux.c32 vesamenu.c32 isolinux.bin
do
	cp /usr/lib/syslinux/$FILE isolinux/
done

	echo "
menu hshift 7
menu width 80

menu title NuTyX ${VERSION_NUTYX} $ISO
include stdmenu.cfg
include install.cfg
include live.cfg

menu end

" > isolinux/menu.cfg

	cat > isolinux/stdmenu.cfg << "EOF"
menu background ../boot/grub/splash.png
menu color title	* #FFFFFFFF *
menu color border	* #00000000 #00000000 none
menu color sel		* #ffffffff #76a1d0ff *
menu color hotsel	1;7;37;40 #ffffffff #76a1d0ff *
menu color tabmsg	* #ffffffff #00000000 *
menu color help		37;40 #ffdddd00 #00000000 none
# XXX When adjusting vshift, take care that rows is set to a small
# enough value so any possible menu will fit on the screen,
# rather than falling off the bottom.
menu vshift 8
menu rows 12
# The help line must be at least one line from the bottom.
menu helpmsgrow 14
# The command line must be at least one line from the help line.
menu cmdlinerow 16
menu timeoutrow 16
menu tabmsgrow 18
menu tabmsg Press ENTER to boot or TAB to edit a menu entry

EOF
	echo "label live
 menu label ^Live
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro quiet live

label live-debug
 menu label li^ve-Debug
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro rootdelay=8 testiso live

label live-toram
 menu label live copied to ^RAM
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro quiet live toram

label live-debug-toram
 menu label live-Debug copied to ^RAM
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro rootdelay=8 testiso live toram

" > isolinux/live.cfg


	echo "default install
label install
 menu label ^Install
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro quiet

label install-debug
 menu label install-^Debug
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro rootdelay=8 testiso

label install-toram
 menu label Install copied to ^RAM
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro quiet toram

label install-debug-toram
 menu label install-Debug copied to RA^M
 kernel /boot/kernel-${VERSION_KERNEL}
 append initrd=/boot/initrd-${VERSION_KERNEL} vga=788 ro rootdelay=8 testiso toram

" > isolinux/install.cfg

	cat > isolinux/isolinux.cfg << "EOF"
path
include menu.cfg
default vesamenu.c32
prompt 0
timeout 100

EOF

# efi stufs
rm -rf iso
rm -rf boot/grub
mkdir -p {iso/EFI,boot/grub/{fonts,${GRUB_EFI_ARCH}-efi}}

# grub
[ -f /usr/share/grub/unicode.pf2 ] && \
	cp /usr/share/grub/unicode.pf2 boot/grub/fonts

[ -f /usr/share/grub/splash.png ] && \
	cp /usr/share/grub/splash.png boot/grub/splash.png

echo "set prefix=/boot/grub" > iso/grub-early.cfg

cp -a /usr/lib/grub/${GRUB_EFI_ARCH}-efi/*.mod \
	/usr/lib/grub/${GRUB_EFI_ARCH}-efi/*.lst \
	boot/grub/${GRUB_EFI_ARCH}-efi


echo "set default=0
set timeout=99

# set debug=all
# set pager=1

insmod all_video
if loadfont /boot/grub/fonts/unicode.pf2; then
  set gfxmode=800x600
  insmod efi_gop
  insmod efi_uga
  insmod video_bochs
  insmod video_cirrus
  insmod gfxterm
  insmod png
  terminal_output gfxterm
fi

if background_image /boot/grub/splash.png; then
  set color_normal=light-gray/black
  set color_highlight=white/black
else
  set color_normal=cyan/blue
  set color_highlight=white/blue
fi

menuentry \"$VERSION_NUTYX $ISO (UEFI) normal\" {

    linux /boot/kernel-${VERSION_KERNEL} ro quiet
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) debug\" {
    set background_color=black
    linux /boot/kernel-${VERSION_KERNEL} ro testiso rootdelay=8
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) copied to RAM\" {

    linux /boot/kernel-${VERSION_KERNEL} ro quiet toram
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) debug copied to RAM\" {
    set background_color=black
    linux /boot/kernel-${VERSION_KERNEL} ro testiso rootdelay=8 toram
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) installable live\" {
    linux /boot/kernel-${VERSION_KERNEL} ro quiet rootdelay=5 live
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) debug live\" {
    linux /boot/kernel-${VERSION_KERNEL} ro testiso rootdelay=8 live
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) installable live copied to RAM\" {
    linux /boot/kernel-${VERSION_KERNEL} ro quiet rootdelay=5 live toram
    initrd /boot/initrd-${VERSION_KERNEL}
}
menuentry \"$VERSION_NUTYX $ISO (UEFI) debug live copied to RAM\" {
    linux /boot/kernel-${VERSION_KERNEL} ro testiso rootdelay=8 live toram
    initrd /boot/initrd-${VERSION_KERNEL}
}" > boot/grub/grub.cfg


for FILE in kernel-stable initrd-stable
do
	[ -f isolinux/$FILE ] && mv -v isolinux/$FILE boot/
done

mkdir -p iso/efiboot EFI/boot

grub-mkimage -c iso/grub-early.cfg -o EFI/boot/${GRUB_EFI_IMG} \
	-O ${GRUB_EFI_ARCH}-efi -p "" iso9660 normal \
	search search_fs_file || error "grub-mkimage"

# efiboot.img
modprobe loop

dd if=/dev/zero of=iso/efiboot.img count=4096

mkdosfs -n "NUTYXEFI" iso/efiboot.img || error "mkdosfs"

mount -o loop iso/efiboot.img iso/efiboot || error "mount efiboot.img"

mkdir -p iso/efiboot/EFI/boot
cp       EFI/boot/${GRUB_EFI_IMG} iso/efiboot/EFI/boot

umount iso/efiboot

# Iso generation

xorriso -as mkisofs -R -l -J -o ${LFS}/${ISO_FILE} \
-A NUTYX \
-b isolinux/isolinux.bin \
-c isolinux/boot.cat -no-emul-boot -boot-load-size 4 \
-boot-info-table \
-eltorito-alt-boot -e iso/efiboot.img -no-emul-boot \
-input-charset utf-8 -V "${LABEL}" .

cd ${LFS}
isohybrid -u ${ISO_FILE} || error "isohybrid ${ISO_FILE}"
}
main() {
	config
	check_variables  "$@"
	check_arch
	parse_options "$@"
	mount_depot
	show_variables
	check_root

	TMP=$(mktemp -d)
	check_tools
	mkdir -p $LFS

	download_pkgadd
	mkdir -p ${LFS}/var/lib/pkg/DB
	install_chroot

	create_locale_link
	make_directories
	install_configuration_files
	install_resolv_conf
	generate_setupfile
	setup_chroot
	enter_chroot
	unmountall
	if [ ! -z "$ISO" ]; then
		generate_squashfs
		generate_iso
	else
		successfull_installation
	fi
	end

}
readonly BASE_COLLECTION=base
readonly VERSION_NUTYX=#VERSION#
readonly RELEASE=1
INSTALL_COMMAND="$(basename $0)"
main "$@"
